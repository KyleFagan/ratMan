<!DOCTYPE html>
<html> <!-- Preview this at:   https://raw.githack.com/KyleFagan/ratMan/main/pacman.html -->
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
        <style>
			xbody { overscroll-behavior-y: contain; }
			body { overscroll-behavior: none; }
		</style>
	</head>
	
	<body onload="init()">
		<canvas style="float: left; border: 1px solid black" id="can1"></canvas>
		<span id='scoreBoard' style='float: left; padding: 15px;'>test</span>
	</body>

<script>
	"use strict"; 

	window.onerror = function(msg, url, linenumber)
	{
		alert('Error message: '+msg+'\nURL: '+url+'\nLine Number: '+linenumber);
		return true;
	}
	
	var red = "rgba(255, 0, 0, 0.8)";
	var green = "rgba(0, 255, 0, 0.8)";
	var blue = "rgba(0, 0, 255, 0.8)";
	var cyan = "rgba(0, 255, 255, 0.8)";
	var orange = "rgba(255, 165,0, 0.8)";
	var yellow = "rgba(255, 255, 204, 0.8)";
	var lightYellow = "rgba(255, 255, 224, 0.8)";
	var pink = "rgba(255, 192, 204, 0.8)";
	var purple = "rgba(160, 32, 240, 0.8)";
	var grey = "rgba(128, 128, 128, 0.8)";
	var black = "rgba(0, 0, 0, 0.8)";
	var white = "rgba(255, 255, 255,0.8)";
	
	var animationFrame = 0;
	var speedDivisor = 5;

	var left = 0;
	var right = 1;
	var up = 2;
	var down = 3;

    var can, ctx;
	var bgColor = "white";
	var wallColor = "brown";
	var deadColor = "black";
	var blocksWide = 10;
	var blocksHigh = 10;
	var blockWidth, blockHeight;
	var numberOfWalls = blocksWide-2;
	var maxTriesToPlaceWalls = numberOfWalls * 100;
	var wallMinLength = 3;
	var walls = [], characters = [], dots = [], destinations = [];
	var audioContext = new AudioContext();

	var score = 0;
	var lives = 3;
	var specialDots = blocksWide/2;
	var scoreForEatingDots = 1;
	var scoreForEatingSpecialDots = 5;
	var scoreForEatingCharacter = 20;
	var scoreForLevelUp = 50;

	var dotsEaten = 0;
	var enemiesEaten = 0;
	var level = 1;
	var playerSpeed = 300;
	var characterSpeed = 400;

	var invinsible = 0;
	var superp = 0;
	var ignoreKeysUntil = 0;
	
	var playerInterval, characterInterval, drawAllInterval, mouthInterval;
	var paused = true;

	var mousestartY = 0;
	var mousestartX = 0;
	var touchstartY = 0;
	var touchstartX = 0;
	

	function handleSwipe(x1, y1, x2, y2)
	{
		var c = characters[0];
		var newX = c.x, newY = c.y, newDirection = c.direction;
		if(x2 < x1-40) { newDirection = 0; newX -= blockWidth; } // left
		if(x2 > x1+40) { newDirection = 1; newX += blockWidth; } // right
		if(y2 < y1-40) { newDirection = 2; newY -= blockHeight; } // up
		if(y2 > y1+40) { newDirection = 3; newY += blockHeight; } // down
		if(isValidMove(newX, newY, blockWidth, blockHeight)) c.direction = newDirection;

		if(paused && (Math.abs(y2-y1) > 40 || Math.abs(x2-x1) > 40)) unPause();

		if(Math.abs(y2-y1) > 200 && Math.abs(x2-x1) > 200) resetGame();
	}
	
	function testBlocks()
	{
		for(var x = 0; x < blocksWide; x++)
		{
			for(var y = 0; y < blocksWide; y++)
			{
				ctx.fillStyle = "yellow";
				if(characterAt(x*blockWidth+5, y*blockHeight+5, blockWidth-10, blockHeight-10))
				{
					ctx.fillStyle = "red";
					ctx.fillRect(x*blockWidth+blockWidth/2, y*blockHeight+blockWidth/2, 20, 20);
				}
				if(wallAt(x*blockWidth+5, y*blockHeight+5, blockWidth-10, blockHeight-10))
				{
					ctx.fillStyle = "green";
					ctx.fillRect(x*blockWidth+blockWidth/2+20, y*blockHeight+blockWidth/2+20, 20, 20);
				}
			}
		}
	}
	
	function makeCharacters()
	{
		for(var i = 0; i < characters.length; i++)
		{
			var c = characters[i];
			setRandomPosition(c);
			c.width = blockWidth;
			c.height = blockHeight;
			while(wallAt(c.x, c.y, c.width, c.height)) setRandomPosition(c);
			drawCharacter(c);
		}
	}
	
    function init()
	{
        can = document.getElementById('can1');
		//can.width = document.documentElement.clientWidth-10;
		//can.height = document.documentElement.clientHeight-10;
		can.width = 700;
		can.height = 700;
		if(can.width > can.height) can.width = can.height;
		if(can.width < can.height) can.height = can.width;
		can.style.backgroundColor = bgColor;
        ctx = can.getContext("2d");
		//ctx.globalAlpha = 0.9;
		
		blockWidth = Math.floor(can.width / blocksWide);
		blockHeight = Math.floor(can.height / blocksHigh);
		
		characters = [ { id: 0, color: yellow }, { id: 1, color: blue }, { id: 2, color: purple }, { id: 3, color: cyan }, { id: 4, color: pink } ];
		destinations = [ { x: 0, y: 0 }, { x: blocksWide*blockWidth, y: 0 }, { x: 0, y: blocksHigh*blockHeight }, { x: blocksWide*blockWidth, y: blocksHigh*blockHeight } ]

		makeCharacters();

		var testing = false;
		if(testing)
		{
			//walls.push( { x: blockWidth*1, y: blockHeight*1, width: blockWidth*3+10, height: blockHeight } );
			makeWalls();
			drawWalls();
			testBlocks();
		}
		
		resetGame();

		can.addEventListener("touchstart",  function(event) {event.preventDefault()}, {passive: false})
		can.addEventListener("touchmove",   function(event) {event.preventDefault()}, {passive: false})
		can.addEventListener("touchend",    function(event) {event.preventDefault()}, {passive: false})
		can.addEventListener("touchcancel", function(event) {event.preventDefault()}, {passive: false})

		document.addEventListener('mousedown', function(event)
		{
			mousestartX = event.pageX;
			mousestartY = event.pageY;
		}, false);
		
		document.addEventListener('mouseup', function(event)
		{
			event.preventDefault();
			handleSwipe(mousestartX, mousestartY, event.pageX, event.pageY);
			mousestartX = 0;
			mousestartY = 0;
		}, false); 

		document.addEventListener('touchstart', function(event)
		{
			event.preventDefault();
			touchstartX = event.changedTouches[0].screenX;
			touchstartY = event.changedTouches[0].screenY;
		}, {passive: false});

		document.addEventListener('touchmove', function(event) { event.preventDefault(); }, {passive: false});
		document.addEventListener('touchcancel', function(event) { event.preventDefault(); }, {passive: false});

		document.addEventListener('touchend', function(event)
		{
			event.preventDefault();
			handleSwipe(touchstartX, touchstartY, event.changedTouches[0].screenX, event.changedTouches[0].screenY);
			touchstartX = 0;
			touchstartY = 0;
		}, {passive: false}); 

        document.addEventListener("keydown", processKeys, false);
	}
	
	function beep(a) // beep({freq:520, duration:200, vol:100, delay:200, times:1}
	{
		if(!a.freq) a.freq = 500;
		if(!a.duration) a.duration = 150;
		if(!a.vol) a.vol = 100;
		if(!a.times) a.times = 1;
		if(!a.delay) a.delay = 170;
		const oscillator = audioContext.createOscillator();
		const gain = audioContext.createGain();
		oscillator.connect(gain);
		oscillator.frequency.value = a.freq;
		oscillator.type = "square";
		gain.connect(audioContext.destination);
		gain.gain.value = a.vol * 0.01;
		oscillator.start(audioContext.currentTime);
		oscillator.stop(audioContext.currentTime + a.duration * 0.001);
		a.times--;
		if(a.times && !paused) setTimeout(function() {beep(a)}, a.delay);
	}

	function resetGame()
	{
		//beep({freq:120, duration: 400});
		//beep({freq:120, duration: 400});
		//beep({freq:1000, duration: 10, delay: 500, times: 20}); // invinsible beep
		ignoreKeysUntil = new Date(new Date().getTime() + 500);
		score = 0;
		lives = 3;
		level = 1;
		playerSpeed = 300;
		characterSpeed = 400;
		resetLevel();
	}
	
	function resetLevel()
	{
		halt();
		makeWalls();
		for(var i = 0; i < characters.length; i++)
		{
			characters[i].dead = 0;
			setRandomPosition(characters[i]);
		}
		invinsible = 2 * speedDivisor;
		superp = 0;
		dotsEaten = 0;
		enemiesEaten = 0;
		resetDots();
		reDrawAll();
		showMessage("Press any key to start!");
	}
	
	function showMessage(msg)
	{
		var width = 400;
		var height = 85;
		var x = can.width/2 - width/2;
		var y = can.height/2 - height/2 -100;
		ctx.fillStyle = "black";
		ctx.fillRect(x, y, width, height);
		ctx.fillStyle = "white";
		ctx.fillRect(x+5, y+5, width-10, height-10);
		ctx.fillStyle = "red";
		ctx.font = "30px Arial";
		ctx.fillText("PacMan", x+30, y+30);
		ctx.fillStyle = "black";
		ctx.fillText(msg, x+30, y+55);
		ctx.font = "20px Arial";
		ctx.fillText("Press P to pause, R to reset game", x+30, y+75);
	}
		
	function makeWalls()
	{
		walls = [];
		var triesLeft = maxTriesToPlaceWalls;
		for(var i = 0; i < numberOfWalls && triesLeft > 0; i++)
		{
			triesLeft--;
			var direction = getRandomInt(0, 1);
			var x1 = getRandomInt(1, blocksWide-2) * blockWidth;
			var y1 = getRandomInt(1, blocksHigh-2) * blockHeight;
			var width1 = getRandomInt(wallMinLength, blocksWide-3-(x1/blockWidth)) * blockWidth;
			var height1 = getRandomInt(wallMinLength, blocksHigh-3-(y1/blockHeight)) * blockHeight;
			
			if(direction == 0) height1 = blockHeight;
			if(direction == 1) width1 = blockWidth;
			if(direction == 0 && wallMinLength * blockWidth > width1) { i--; continue; }
			if(direction == 1 && wallMinLength * blockHeight > height1) { i--; continue; }
			
			if(
				!wallAt(x1-blockWidth, y1-blockHeight, width1, height1) &&
				!wallAt(x1+blockWidth, y1+blockHeight, width1, height1) &&
				!wallAt(x1, y1, blockWidth, blockHeight)
				//!wallAt(x1-blockWidth, y1-blockHeight, blockWidth*3, blockHeight*3)
			) walls.push( { x: x1, y: y1, width: width1, height: height1 } );
			else i--;
		}
		if(triesLeft == 0) console.log("ran out of wall space");
	}
	
	function setRandomPosition(c)
	{
		c.x = -1;
		c.y = -1;
		while(!isValidMove(c.x, c.y, c.width, c.height))
		{
			c.x = getRandomInt(0, blocksWide-1)*blockWidth;
			c.y = getRandomInt(0, blocksHigh-1)*blockHeight;
		}
	}
	
	function pause()
	{
		halt();
		reDrawAll();
		showMessage("Press any key to unpause!");
	}

	function halt()
	{
		paused = true;
		if(playerInterval) clearInterval(playerInterval);
		if(characterInterval) clearInterval(characterInterval);
		if(drawAllInterval) clearInterval(drawAllInterval);
		if(mouthInterval) clearInterval(mouthInterval);
		animate();
	}
	
	function showScore()
	{
		var player = characters[0];
		document.getElementById("scoreBoard").innerHTML =
		"Level: " + level + "<br>" +
		"Score: " + score + "<br>" +
		"Dots eaten: " + dotsEaten + " of " + dots.length + "<br>" +
		"Ghost eaten: " + enemiesEaten + "<br>" +
		"Lives: " + lives + "<br>" +
		"PlayerSpeed: " + playerSpeed + "<br>" +
		"GhostSpeed: " + characterSpeed + "<br>" +
		"Player x: " + player.x + "<br>" +
		"Player y: " + player.y + "<br>" +
		"can.width: " + can.width + "<br>" +
		"can.height: " + can.height + "<br>" +
		"blockWidth: " + blockWidth + "<br>" +
		"blockHeight: " + blockHeight + "<br>" +
		"";
	}

	function reDrawAll()
	{
		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, can.width, can.height); // clear canvas
		if(dots != null) drawDots();
		drawWalls();
		for(var i = characters.length-1; i >= 0; i--) drawCharacter(characters[i]);
		showScore();
	}
	
	function animate()
	{
		if(!paused)
		{
			for(var i = characters.length-1; i >= 0; i--) drawCharacter(characters[i]);
			showScore();
			//if(invinsible > 0 && animationFrame % 10 == 0) beep({freq:1000, duration: 10}); // invinsible beep
			//if(superp > 0 && animationFrame % 15 == 0) beep({freq:1000, duration: 10}); // invinsible beep
			animationFrame++;
		}
		window.requestAnimationFrame(animate);
	}
	
	function unPause()
	{
		paused = false;
		if(audioContext == null) audioContext = new AudioContext();
		playerInterval = setInterval(movePlayer, playerSpeed/speedDivisor);
		characterInterval = setInterval(moveCharacter, characterSpeed/speedDivisor);
		mouthInterval = setInterval(openCloseMouth, 150);
		reDrawAll();
    }
	
	function openCloseMouth() { characters[0].mouthClosed = !characters[0].mouthClosed; }

	function playerDies()
	{
		if(audioContext == null) audioContext = new AudioContext();
		//beep({freq:120, duration: 400});
		//beep({freq:1000, duration: 10, delay: 1500, times: 20}); // invinsible beep
		score = 0;
		lives--;
		invinsible = 15;
		if(lives <= 0) resetGame();
	}
	
	function levelUp()
	{
		score += scoreForLevelUp;
		characterSpeed -= 5;
		if(characterSpeed < playerSpeed) characterSpeed = playerSpeed;
		level++;
		resetLevel();
	}
	
	function getDots(x, y)
	{
		var dotMatches = [];
		for(var i=0; i < dots.length; i++) if(collisionTest(x, y, blockWidth, blockHeight, dots[i].x, dots[i].y, dots[i].width, dots[i].height)) dotMatches.push(dots[i]);
		return dotMatches;
	}
	
	function eatDot(x, y)
	{
		var dotMatches = getDots(x, y);
		for(var i = 0; i < dotMatches.length; i++)
		{
			var dot = dotMatches[i];
			if(dot.eaten) continue;
			if(dot.special)
			{
				superp = 30 * speedDivisor;
				score += scoreForEatingSpecialDots;
				//beep({freq:1000, duration: 10, delay: 500, times: 20}); // invinsible beep
			}
			else score += scoreForEatingDots;
			dotsEaten++;
			dot.eaten = true;
			showScore();
			if(dotsEaten == dots.length) levelUp();
		}
	}

	function drawDot(x, y)
	{
		var dotMatches = getDots(x, y);
		for(var i = 0; i < dotMatches.length; i++)
		{
			var dot = dotMatches[i];
			var size = blockWidth/6;
			ctx.fillStyle = orange;
			if(dot.eaten) ctx.fillStyle = lightYellow;
			if(!dot.eaten && dot.special) ctx.fillStyle = "green";
			if(dot.special) size = blockWidth/4;
			ctx.beginPath();
			ctx.arc(dot.x+blockWidth/2, dot.y+blockHeight/2, size, 0.2 * Math.PI, 2 * Math.PI, false); 
			ctx.fill();
		}
	}
	
	function resetDots()
	{
		dots = [];
		for(var x = 0; x < blocksWide; x++)
		{
			for(var y = 0; y < blocksHigh; y++)
			{
				if(isValidMove(x*blockWidth, y*blockHeight, blockWidth, blockHeight))
				{
					dots.push({ x: x*blockWidth, y: y*blockHeight, width: blockWidth, height: blockHeight });
				}
			}
		}

		for(var i=0; i < specialDots; i++)
		{
			var dot = dots[getRandomInt(0, dots.length-1)];
			dot.special = true;
		}
	}
	
	function drawDots()
	{
		for(var i=0; i < dots.length; i++)
		{
			drawDot(dots[i].x, dots[i].y);
		}
	}
	
    function drawWalls()
	{
		for(var i = 0; i < walls.length; i++)
		{
			if(walls[i].color == undefined) walls[i].color = wallColor;
			ctx.fillStyle = walls[i].color;
			ctx.fillRect(walls[i].x, walls[i].y, walls[i].width, walls[i].height);
		}
    }
	
    function drawCharacter(c)
	{
		if(c.width == undefined) c.width = blockWidth*.8;
		if(c.height == undefined) c.height = blockWidth*.8;
		ctx.fillStyle = bgColor;
		ctx.fillRect(c.oldX, c.oldY, blockWidth, blockHeight); // erase previous location
		if(c.oldX != null) drawDot(c.oldX, c.oldY)
		ctx.fillStyle = bgColor;
		ctx.fillRect(c.x, c.y, blockWidth, blockHeight); // erase current location
		ctx.fillStyle = c.color;
		if(c.dead > 0) ctx.fillStyle = deadColor;
		var num1 = 2;//1.6; // 1.6
		var num2 = 3; // 

		if(c.id == 0)
		{
			ctx.strokeStyle = grey;
			ctx.strokeRect(c.x+2, c.y+2, c.width-4, c.height-4);
			if(invinsible) ctx.fillStyle = orange;
			if(superp) ctx.fillStyle = red;
			ctx.beginPath();
			var mouthOpenValue = 30;
			// left, right, up, down (180, 0, 270?, 90?)
			if(c.mouthClosed) mouthOpenValue = 1;
			if (c.direction == 0) ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * (179 - mouthOpenValue), (Math.PI / 180) * (180 + mouthOpenValue), true);
			else if (c.direction == 1) ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * mouthOpenValue, (Math.PI / 180) * (360 - mouthOpenValue));
			else if (c.direction == 2) ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * (269 - mouthOpenValue), (Math.PI / 180) * (270 + mouthOpenValue), true);
			else ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * (89 + mouthOpenValue), (Math.PI / 180) * (90 - mouthOpenValue));
			ctx.lineTo(c.x + c.width/num1, c.y + c.width/num1); // mouth
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}
		else
		{
			ctx.beginPath();
			ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, 0, 2 * Math.PI, false); // body
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}
		c.oldX = c.x;
		c.oldY = c.y;
    }
	
    function movePlayer()
	{
		if(invinsible > 0) invinsible--;
		if(superp > 0) superp--;
		var player = characters[0];
		var newX = player.x, newY = player.y, newDirection = player.direction;
		
		if(newDirection === 0) newX = player.x - blockWidth/speedDivisor;
		if(newDirection === 1) newX = player.x + blockWidth/speedDivisor;
		if(newDirection === 2) newY = player.y - blockWidth/speedDivisor;
		if(newDirection === 3) newY = player.y + blockWidth/speedDivisor;

		if(isValidMove(newX, newY, blockWidth, blockHeight))
		{
			player.x = newX;
			player.y = newY;
			if(!invinsible) eatDot(player.x, player.y);
			
			var c = characterAt(player.x, player.y, blockWidth, blockWidth, player.id);
			if(c != null && !c.dead)
			{
				if(superp) eatCharacter(c);
				if(!superp && !invinsible) playerDies();
			}
		}
    }
	
	function eatCharacter(c)
	{
		//beep({freq:800, duration: 400});
		enemiesEaten++;
		score += scoreForEatingCharacter;
		//setRandomPosition(c);
		c.dead = 30 * speedDivisor;
	}
	
    function processKeys(e)
	{
		if(e.ctrlKey) return; // ignore all ctrl keys
		if(event.keyCode < 32 || event.keyCode > 110) return; // ignore alt, tab, other strange command characters
		if(ignoreKeysUntil > 0 && ignoreKeysUntil > new Date().getTime()) return;
		ignoreKeysUntil = 0;

		var player = characters[0];
		var newX = player.x, newY = player.y, newDirection = player.direction;
		if(e.key === "ArrowLeft" || e.key === "a") { newDirection = 0; newX -= blockWidth/speedDivisor; }
		if(e.key === "ArrowRight" || e.key === "d") { newDirection = 1; newX += blockWidth/speedDivisor; }
		if(e.key === "ArrowUp" || e.key === "w") { newDirection = 2; newY -= blockWidth/speedDivisor; }
		if(e.key === "ArrowDown" || e.key === "s") { newDirection = 3; newY += blockWidth/speedDivisor; }
		if(isValidMove(newX, newY, blockWidth, blockWidth)) player.direction = newDirection;

		if(e.key === "p") { if(!paused) pause(); else unPause(); }
		else if(paused) unPause(); // anykey unpauses
		if(e.key === "r") resetGame();
		if(e.key === "l") levelUp();
    }
	
    function moveCharacter()
	{
		var player = characters[0];
		for(var characterNum = 1; characterNum < characters.length; characterNum++)
		{
			var c = characters[characterNum];
			if(c.dead > 0) { c.dead--; continue; }
			var playerDistance = getDistance(player.x, c.x, player.y, c.y);
			var bestX = c.x;
			var bestY = c.y;
			var scramble = [ 0, 1, 2, 3 ];
			scramble.sort(() => Math.random() - 0.5);
			for(var i = 0; i < 4; i++)
			{
				var newX = c.x;
				var newY = c.y;
				if(i === scramble[0]) { newX = c.x - blockWidth/speedDivisor; }
				if(i === scramble[1]) { newX = c.x + blockWidth/speedDivisor; }
				if(i === scramble[2]) { newY = c.y - blockWidth/speedDivisor; }
				if(i === scramble[3]) { newY = c.y + blockWidth/speedDivisor; }
				if(!isValidMove(newX, newY, blockWidth, blockHeight)) continue;
				
				if(c.dest == undefined) c.dest = getRandomInt(0, destinations.length-1);
				var destX = destinations[c.dest].x;
				var destY = destinations[c.dest].y; 
				if(!invinsible && !superp && playerDistance < 200) { destX = player.x; destY = player.y; }

				var bestDistance = getDistance(destX, bestX, destY, bestY);
				var newDistance = getDistance(destX, newX, destY, newY);
				if(newDistance < bestDistance) { bestX = newX; bestY = newY; }
			}
			if(bestX == c.x && bestY == c.y) c.dest = getRandomInt(0, destinations.length-1); // stuck, change destination
			c.x = bestX;
			c.y = bestY;
			var c2 = characterAt(c.x, c.y, blockWidth, blockWidth);
			if(c2 != null && !c.dead && c2.id == 0)
			{
				if(superp) eatCharacter(c);
				if(!superp && !invinsible) playerDies();
			}
		}
    }
	
	function getDistance(x1, x2, y1, y2)
	{
		var distance = 0;
		distance = Math.abs(x1 - x2) + Math.abs(y1 - y2); // (10)-(20)=-10 (-10)-(-10)=0. (-10)-(-30)=20. (-20)-(20)=-40
		return distance;
	}
	
	function isValidMove(x, y, width, height)
	{
		if(x < 0) return false;
		if(x + blockWidth > can.width) return false;
		if(y < 0) return false;
		if(y + blockHeight > can.height) return false;
		return !wallAt(x, y, width, height);
	}
	
	function wallAt(x, y, width, height)
	{
		for(var i = 0; i < walls.length; i++)
		{
			if(collisionTest(x, y, width, height, walls[i].x, walls[i].y, walls[i].width, walls[i].height)) return walls[i];
		}
		return null;
	}
	
	function collisionTest(x1, y1, width1, height1, x2, y2, width2, height2)
	{
		if(
		x1 + width1 > x2 &&
		x1 < x2 + width2 &&
		y1 + height1 > y2 &&
		y1 < y2 + height2) return true;
		return false;
	}

	function characterAt(x, y, width, height, notId)
	{
		var i = 0;
		if(notId == 0) i = 1;
		for(; i < characters.length; i++)
		{
			var c = characters[i];
			if(!c.dead && collisionTest(x, y, width, height, c.x, c.y, c.width, c.height)) return c;
		}
		return null;
	}
		
	function getRandomInt(min, max)
	{	
		if(min > max) { var temp = min; min = max; max = temp; }
		min = Math.ceil(min);
		max = Math.floor(max);
		if(max > 0) max++;
		return Math.floor(Math.random() * (max - min) + min);
	}
 
</script>

</html>
