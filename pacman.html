<!DOCTYPE html>
<html> <!-- Preview this at:   https://raw.githack.com/KyleFagan/ratMan/main/pacman.html -->
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
        <style>
			xbody { overscroll-behavior-y: contain; }
			body { overscroll-behavior: none; }
		</style>
	</head>
	
	<body onload="init()">
		<canvas style="float: left;" id="can1"></canvas>
		<span id='scoreBoard' style='float: left; padding: 15px;'>test</span>
	</body>

<script>
	"use strict"; 

	window.onerror = function(msg, url, linenumber)
	{
		alert('Error message: '+msg+'\nURL: '+url+'\nLine Number: '+linenumber);
		return true;
	}
	
	var animationFrame = 0;

    var can, ctx;
	var bgColor = "white";
	var blocksWide = 8;
	var blocksHigh = 8;
	var blockWidth, blockHeight;
	var numberOfWalls = blocksWide;
	var maxTriesToPlaceWalls = numberOfWalls * 100;
	var wallMinLength = blocksWide / 10;
	if(blocksHigh < blocksWide) wallMinLength = blocksHigh / 10;
	var walls, characters, dots, destinations;
	var audioContext = new AudioContext();

	var score = 0;
	var lives = 3;
	var specialDots = blocksWide/2;
	var scoreForEatingDots = 1;
	var scoreForEatingSpecialDots = 5;
	var scoreForEatingCharacter = 20;
	var scoreForLevelUp = 50;

	var dotsEaten = 0;
	var enemiesEaten = 0;
	var level = 1;
	var playerSpeed = 250;
	var characterSpeed = 300;

	var invinsible = 0;
	var superp = 0;
	var ignoreKeysUntil = 0;
	
	var playerInterval, characterInterval, drawAllInterval, mouthInterval;
	var paused = true;

	var mousestartY = 0;
	var mousestartX = 0;
	var touchstartY = 0;
	var touchstartX = 0;
	

	function handleSwipe(x1, y1, x2, y2)
	{
		var c = characters[0];
		var newX = c.x, newX2 = c.x, newY = c.y, newY2 = c.y, newDirection = c.direction;

		if(x2 < x1-40) { newDirection = 0; newX -= blockWidth; newX2 -= blockWidth*2; } // left
		if(x2 > x1+40) { newDirection = 1; newX += blockWidth; newX2 += blockWidth*2; } // right
		if(y2 < y1-40) { newDirection = 2; newY -= blockHeight; newY2 -= blockWidth*2; } // up
		if(y2 > y1+40) { newDirection = 3; newY += blockHeight; newY2 += blockWidth*2; } // down
		if(isValidMove(newX, newY, c.width, c.height)) c.direction = newDirection;

		if(paused && (Math.abs(y2-y1) > 40 || Math.abs(x2-x1) > 40)) unPause();

		if(Math.abs(y2-y1) > 200 && Math.abs(x2-x1) > 200) resetGame();
	}
	
	
    function init()
	{
        can = document.getElementById('can1');
		can.width = document.documentElement.clientWidth-10;
		can.height = document.documentElement.clientHeight-10;
		if(can.width > can.height) can.width = can.height;
		if(can.width < can.height) can.height = can.width;
		can.style.backgroundColor = bgColor;
        ctx = can.getContext("2d");
		blockWidth = Math.floor(can.width / blocksWide);
		blockHeight = Math.floor(can.height / blocksHigh);
		characters = [ { id: 0, color: "yellow" }, { id: 1, color: "blue" }, { id: 2, color: "purple" }, { id: 3, color: "black" }, { id: 4, color: "pink" } ];
		destinations = [ { x: 0, y: 0 }, { x: blocksWide*blockWidth, y: 0 }, { x: 0, y: blocksHigh*blockHeight }, { x: blocksWide*blockWidth, y: blocksHigh*blockHeight } ]

can.addEventListener("touchstart",  function(event) {event.preventDefault()})
can.addEventListener("touchmove",   function(event) {event.preventDefault()})
can.addEventListener("touchend",    function(event) {event.preventDefault()})
can.addEventListener("touchcancel", function(event) {event.preventDefault()})

		document.addEventListener('mousedown', function(event)
		{
			mousestartX = event.pageX;
			mousestartY = event.pageY;
		}, false);
		
		document.addEventListener('mouseup', function(event)
		{
			event.preventDefault();
			handleSwipe(mousestartX, mousestartY, event.pageX, event.pageY);
			mousestartX = 0;
			mousestartY = 0;
		}, false); 

		document.addEventListener('touchstart', function(event)
		{
			event.preventDefault();
			touchstartX = event.changedTouches[0].screenX;
			touchstartY = event.changedTouches[0].screenY;
		}, false);

		document.addEventListener('touchmove', function(event)
		{
			event.preventDefault();
		}, false);

		document.addEventListener('touchcancel', function(event)
		{
			event.preventDefault();
		}, false);

		document.addEventListener('touchend', function(event)
		{
			event.preventDefault();
			handleSwipe(touchstartX, touchstartY, event.changedTouches[0].screenX, event.changedTouches[0].screenY);
			touchstartX = 0;
			touchstartY = 0;
		}, false); 

		resetGame();
        document.addEventListener("keydown", processKeys, false);
	}
	
	function beep(a) // beep({freq:520, duration:200, vol:100, delay:200, times:1}
	{
		if(!a.freq) a.freq = 500;
		if(!a.duration) a.duration = 150;
		if(!a.vol) a.vol = 100;
		if(!a.times) a.times = 1;
		if(!a.delay) a.delay = 170;
		const oscillator = audioContext.createOscillator();
		const gain = audioContext.createGain();
		oscillator.connect(gain);
		oscillator.frequency.value = a.freq;
		oscillator.type = "square";
		gain.connect(audioContext.destination);
		gain.gain.value = a.vol * 0.01;
		oscillator.start(audioContext.currentTime);
		oscillator.stop(audioContext.currentTime + a.duration * 0.001);
		a.times--;
		if(a.times && !paused) setTimeout(function() {beep(a)}, a.delay);
	}

	function resetGame()
	{
		//beep({freq:120, duration: 400});
		//beep({freq:120, duration: 400});
		//beep({freq:1000, duration: 10, delay: 500, times: 20}); // invinsible beep
		ignoreKeysUntil = new Date(new Date().getTime() + 500);
		score = 0;
		lives = 3;
		dotsEaten = 0;
		enemiesEaten = 0;
		level = 1;
		playerSpeed = 250;
		characterSpeed = 300;
		resetLevel();
	}
	
	function resetLevel()
	{
		halt();
		makeWalls();
		for(var i = 0; i < characters.length; i++) setRandomPosition(characters[i]);
		invinsible = 2;
		resetDots();
		reDrawAll();
		showMessage("Press any key to start!");
	}
	
	function showMessage(msg)
	{
		var width = 400;
		var height = 85;
		var x = can.width/2 - width/2;
		var y = can.height/2 - height/2 -100;
		ctx.fillStyle = "black";
		ctx.fillRect(x, y, width, height);
		ctx.fillStyle = "white";
		ctx.fillRect(x+5, y+5, width-10, height-10);
		ctx.fillStyle = "red";
		ctx.font = "30px Arial";
		ctx.fillText("PacMan", x+30, y+30);
		ctx.fillStyle = "black";
		ctx.fillText(msg, x+30, y+55);
		ctx.font = "20px Arial";
		ctx.fillText("Press P to pause, R to reset game", x+30, y+75);
	}
		
	function makeWalls()
	{
		walls = [];
		var triesLeft = maxTriesToPlaceWalls;
		for(var i = 0; i < numberOfWalls && triesLeft > 0; i++)
		{
			triesLeft--;
			var direction = getRandomInt(0, 1);
			var x1 = getRandomInt(0, blocksWide-1) * blockWidth;
			var y1 = getRandomInt(0, blocksHigh-1) * blockHeight;
			var width1 = getRandomInt(wallMinLength, blocksWide-3-(x1/blockWidth)) * blockWidth;
			var height1 = getRandomInt(wallMinLength, blocksHigh-3-(y1/blockHeight)) * blockHeight;
			
			if(direction == 0) height1 = blockHeight;
			if(direction == 1) width1 = blockWidth;
			if(direction == 0 && wallMinLength * blockWidth > width1) { i--; continue; }
			if(direction == 1 && wallMinLength * blockHeight > height1) { i--; continue; }
			
			if(
				!isWallAt(x1-blockWidth, y1-blockHeight, width1, height1) &&
				!isWallAt(x1+blockWidth, y1+blockHeight, width1, height1) &&
				!isWallAt(x1, y1, blockWidth, blockHeight)
				//!isWallAt(x1-blockWidth, y1-blockHeight, blockWidth*3, blockHeight*3)
			) walls.push( { x: x1, y: y1, width: width1, height: height1 } );
			else i--;
		}
		if(triesLeft == 0) console.log("ran out of wall space");
	}
	
	function setRandomPosition(c)
	{
		c.x = -1;
		c.y = -1;
		//while(!isValidMove(c.x, c.y, c.width, c.height) || characterAt(c.x, c.y, c.id))
		while(!isValidMove(c.x, c.y, c.width, c.height))
		{
			c.x = getRandomInt(0, blocksWide-1)*blockWidth;
			c.y = getRandomInt(0, blocksHigh-1)*blockHeight;
		}
	}
	
	function pause()
	{
		halt();
		reDrawAll();
		showMessage("Press any key to unpause!");
	}

	function halt()
	{
		paused = true;
		if(playerInterval) clearInterval(playerInterval);
		if(characterInterval) clearInterval(characterInterval);
		if(drawAllInterval) clearInterval(drawAllInterval);
		if(mouthInterval) clearInterval(mouthInterval);
		animate();
	}
	
	function showScore()
	{
		document.getElementById("scoreBoard").innerHTML =
		"Level: " + level + "<br>" +
		"Score: " + score + "<br>" +
		"Dots eaten: " + dotsEaten + " of " + dots.length + "<br>" +
		"Ghost eaten: " + enemiesEaten + "<br>" +
		"Lives: " + lives + "<br>" +
		"PlayerSpeed: " + playerSpeed + "<br>" +
		"GhostSpeed: " + characterSpeed + "<br>" +
		"";
	}

	function reDrawAll()
	{
		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, can.width, can.height); // clear canvas
		drawDots();
		drawWalls();
		for(var i = characters.length-1; i >= 0; i--) drawCharacter(characters[i]);
		showScore();
	}
	
	function animate()
	{
		if(!paused)
		{
			for(var i = characters.length-1; i >= 0; i--) drawCharacter(characters[i]);
			showScore();
			//if(invinsible > 0 && animationFrame % 10 == 0) beep({freq:1000, duration: 10}); // invinsible beep
			//if(superp > 0 && animationFrame % 15 == 0) beep({freq:1000, duration: 10}); // invinsible beep
			animationFrame++;
		}
		window.requestAnimationFrame(animate);
	}
	
	function unPause()
	{
		paused = false;
		if(audioContext == null) audioContext = new AudioContext();
		playerInterval = setInterval(playerMove, playerSpeed);
		characterInterval = setInterval(characterMove, characterSpeed);
		mouthInterval = setInterval(openCloseMouth, 150);
		reDrawAll();
    }
	
	function openCloseMouth() { characters[0].mouthClosed = !characters[0].mouthClosed; }

	function playerDies()
	{
		if(audioContext == null) audioContext = new AudioContext();
		//beep({freq:120, duration: 400});
		//beep({freq:1000, duration: 10, delay: 1500, times: 20}); // invinsible beep
		score = 0;
		lives--;
		invinsible = 15;
		if(lives <= 0) resetGame();
	}

	function eatDot(x, y)
	{
		var dot = getDot(x, y);
		if(dot && !dot.eaten)
		{
			if(dot.special)
			{
				superp = 30;
				score += scoreForEatingSpecialDots;
				//beep({freq:1000, duration: 10, delay: 500, times: 20}); // invinsible beep
			}
			else score += scoreForEatingDots;
			dotsEaten++;
			dot.eaten = true;
			showScore();
			if(dotsEaten == dots.length) levelUp();
		}
	}
	
	function levelUp()
	{
		score += scoreForLevelUp;
		characterSpeed -= 5;
		if(characterSpeed < playerSpeed) characterSpeed = playerSpeed;
		specialDots += 5
		if(specialDots > 50) specialDots = 50;
		dotsEaten = 0;
		level++;
		resetLevel();
	}
	
	function getDot(x, y)
	{
		for(var i=0; i < dots.length; i++) if(dots[i].x == x && dots[i].y == y) return dots[i];
	}
	
	function drawDot(x, y)
	{
		var dot = getDot(x, y);
		if(dot && !dot.eaten)
		{
			var size = blockWidth/6;
			ctx.fillStyle = "orange";
			if(dot.eaten) ctx.fillStyle = "black";
			if(dot.special) ctx.fillStyle = "green";
			if(dot.special) size = blockWidth/4;
			ctx.beginPath();
			ctx.arc(dot.x+blockWidth/2, dot.y+blockHeight/2, size, 0.2 * Math.PI, 2 * Math.PI, false); 
			ctx.fill();
		}
	}
	
	function resetDots()
	{
		dots = [];
		for(var x = 0; x < blocksWide; x++)
		{
			for(var y = 0; y < blocksHigh; y++)
			{
				if(isValidMove(x*blockWidth, y*blockHeight, blockWidth, blockHeight))
				{
					dots.push({ x: x*blockWidth, y: y*blockHeight });
				}
			}
		}

		for(var i=0; i < specialDots; i++)
		{
			var dot = dots[getRandomInt(0, dots.length-1)];
			dot.special = true;
		}
	}
	
	function drawDots()
	{
		for(var i=0; i < dots.length; i++)
		{
			drawDot(dots[i].x, dots[i].y);
		}
	}
	
    function drawWalls()
	{
		for(var i = 0; i < walls.length; i++)
		{
			if(walls[i].color == undefined) walls[i].color = "brown";
			ctx.fillStyle = walls[i].color;
			ctx.fillRect(walls[i].x, walls[i].y, walls[i].width, walls[i].height);
		}
    }
	
    function drawCharacter(c)
	{
		if(c.width == undefined) c.width = blockWidth*.8;
		if(c.height == undefined) c.height = blockWidth*.8;

		ctx.fillStyle = bgColor;
		ctx.fillRect(c.oldX, c.oldY, blockWidth, blockHeight); // erase previous location
		if(c.oldX != null) drawDot(c.oldX, c.oldY)
		ctx.fillStyle = bgColor;
		ctx.fillRect(c.x, c.y, blockWidth, blockHeight); // erase current location
		
		ctx.fillStyle = c.color;
		
		var num1 = 1.6; // 1.6
		var num2 = 3; // 

		if(c.id == 0)
		{
			if(invinsible) ctx.fillStyle = "orange";
			if(superp) ctx.fillStyle = "red";
			ctx.beginPath();
			var mouthOpenValue = 30;
			// left, right, up, down (180, 0, 270?, 90?)
			if(c.mouthClosed) mouthOpenValue = 1;
			if (c.direction == 0) ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * (179 - mouthOpenValue), (Math.PI / 180) * (180 + mouthOpenValue), true);
			else if (c.direction == 1) ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * mouthOpenValue, (Math.PI / 180) * (360 - mouthOpenValue));
			else if (c.direction == 2) ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * (269 - mouthOpenValue), (Math.PI / 180) * (270 + mouthOpenValue), true);
			else ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, (Math.PI / 180) * (89 + mouthOpenValue), (Math.PI / 180) * (90 - mouthOpenValue));
			ctx.lineTo(c.x + c.width/num1, c.y + c.width/num1); // mouth
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}
		else
		{
			ctx.beginPath();
			ctx.arc(c.x+c.width/num1, c.y+c.width/num1, c.width/num2, 0, 2 * Math.PI, false); // body
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}
		c.oldX = c.x;
		c.oldY = c.y;
    }
	
    function playerMove()
	{
		if(invinsible > 0) invinsible--;
		if(superp > 0) superp--;
		var player = characters[0];
		var newX = player.x, newY = player.y, newDirection = player.direction;
		
		if(newDirection === 0) newX = player.x - blockWidth;
		if(newDirection === 1) newX = player.x + blockWidth;
		if(newDirection === 2) newY = player.y - blockHeight;
		if(newDirection === 3) newY = player.y + blockHeight;

		if(isValidMove(newX, newY, player.width, player.height))
		{
			player.x = newX;
			player.y = newY;
			eatDot(player.x, player.y);
			var c = characterAt(player.x, player.y);
			if(c != null && !superp && !invinsible) playerDies();
			if(c != null && superp) eatCharacter(c);
		}
    }
	
	function eatCharacter(c)
	{
		//beep({freq:800, duration: 400});
		enemiesEaten++;
		score += scoreForEatingCharacter;
		setRandomPosition(c);
	}
	
    function processKeys(e)
	{
		if(e.ctrlKey) return; // ignore all ctrl keys
		if(event.keyCode < 32 || event.keyCode > 110) return; // ignore alt, tab, other strange command characters
		if(ignoreKeysUntil > 0 && ignoreKeysUntil > new Date().getTime()) return;
		ignoreKeysUntil = 0;

		var c = characters[0];
		var newX = c.x, newX2 = c.x, newY = c.y, newY2 = c.y, newDirection = c.direction;
		if(e.key === "ArrowLeft" || e.key === "a") { newDirection = 0; newX -= blockWidth; newX2 -= blockWidth*2; }
		if(e.key === "ArrowRight" || e.key === "d") { newDirection = 1; newX += blockWidth; newX2 += blockWidth*2; }
		if(e.key === "ArrowUp" || e.key === "w") { newDirection = 2; newY -= blockHeight; newY2 -= blockWidth*2; }
		if(e.key === "ArrowDown" || e.key === "s") { newDirection = 3; newY += blockHeight; newY2 += blockWidth*2; }
		if(isValidMove(newX, newY, c.width, c.height)) c.direction = newDirection;

		if(e.key === "p") { if(!paused) pause(); else unPause(); }
		else if(paused) unPause(); // anykey unpauses
		if(e.key === "r") resetGame();
		if(e.key === "l") levelUp();
    }
	
    function characterMove()
	{
		var player = characters[0];
		for(var characterNum = 1; characterNum < characters.length; characterNum++)
		{
			var c = characters[characterNum];
			var playerDistance = getDistance(player.x, c.x, player.y, c.y);
			var bestX = c.x;
			var bestY = c.y;
			var scramble = [ 0, 1, 2, 3 ];
			scramble.sort(() => Math.random() - 0.5);
			for(var i = 0; i < 4; i++)
			{
				var newX = c.x;
				var newY = c.y;
				if(i === scramble[0]) newX = c.x - blockWidth;
				if(i === scramble[1]) newX = c.x + blockWidth;
				if(i === scramble[2]) newY = c.y - blockHeight;
				if(i === scramble[3]) newY = c.y + blockHeight;
				if(!isValidMove(newX, newY, c.width, c.height)) continue;
				
				if(c.dest == undefined) c.dest = getRandomInt(0, destinations.length-1);
				var destX = destinations[c.dest].x;
				var destY = destinations[c.dest].y; 
				if(!invinsible && !superp && playerDistance < 200) { destX = player.x; destY = player.y; }

				var bestDistance = getDistance(destX, bestX, destY, bestY);
				var newDistance = getDistance(destX, newX, destY, newY);
				if(newDistance < bestDistance) { bestX = newX; bestY = newY; }
			}
			if(bestX == c.x && bestY == c.y) c.dest = getRandomInt(0, destinations.length-1); // stuck, change destination
			c.x = bestX;
			c.y = bestY;
			if(isPlayerAt(c.x, c.y) && !superp && !invinsible) playerDies();
			if(isPlayerAt(c.x, c.y) && superp) setRandomPosition(c);
		}
    }
	
	function getDistance(x1, x2, y1, y2)
	{
		var distance = 0;
		distance = Math.abs(x1 - x2) + Math.abs(y1 - y2); // (10)-(20)=-10 (-10)-(-10)=0. (-10)-(-30)=20. (-20)-(20)=-40
		return distance;
	}
	
	function isValidMove(newX, newY, width, height)
	{
		if(newX < 0) return false;
		if(newX + width > can.width) return false;
		if(newY < 0) return false;
		if(newY + height > can.height) return false;
		return !isWallAt(newX, newY, width, height);
	}
	
	function isWallAt(newX, newY, width, height)
	{
		for(var i = 0; i < walls.length; i++)
		{
			if(collisionTest(newX, newY, width, height, walls[i].x, walls[i].y, walls[i].width, walls[i].height)) return true;
		}
		return false;
	}
	
	function collisionTest(x1, y1, width1, height1, x2, y2, width2, height2)
	{
		if(
		x1 + width1 > x2 &&
		x1 < x2 + width2 &&
		y1 + height1 > y2 &&
		y1 < y2 + height2) return true;
		return false;
	}
	
	function characterAt(x, y, notCharacterId)
	{
		for(var i = 1; i < characters.length; i++)
		{
			if(characters[i].id != notCharacterId && x == characters[i].x && y == characters[i].y) return characters[i];
		}
		return null;
	}
	
	function isPlayerAt(x, y) { return characters[0].x == x && characters[0].y == y; }
	
	function getRandomInt(min, max)
	{	
		if(min > max) { var temp = min; min = max; max = temp; }
		min = Math.ceil(min);
		max = Math.floor(max);
		if(max > 0) max++;
		return Math.floor(Math.random() * (max - min) + min);
	}
 
</script>

</html>
		
		
		
		
 
