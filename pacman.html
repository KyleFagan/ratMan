<!DOCTYPE html>
<html> <!-- Preview this at:   https://raw.githack.com/KyleFagan/ratMan/main/pacman.html -->
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no">
        <style>
			xbody { overscroll-behavior-y: contain; }
			body { overscroll-behavior: none; }
		</style>
	</head>
	
	<body onload="init()">
		<canvas style="float: left; border: 1px solid black" id="can1"></canvas>
		<span id='scoreBoard' style='float: left; padding: 15px;'>test</span>
	</body>

<script>
	"use strict"; 

	window.onerror = function(msg, url, linenumber)
	{
		alert('Error message: '+msg+'\nURL: '+url+'\nLine Number: '+linenumber);
		return true;
	}
	
	var red = "rgba(255, 0, 0, 0.8)";
	var green = "rgba(0, 255, 0, 0.8)";
	var blue = "rgba(0, 0, 255, 0.8)";
	var cyan = "rgba(0, 255, 255, 0.8)";
	var orange = "rgba(255, 165,0, 0.8)";
	var yellow = "rgba(255, 255, 204, 0.8)";
	var lightYellow = "rgba(255, 255, 224, 0.8)";
	var pink = "rgba(255, 192, 204, 0.8)";
	var purple = "rgba(160, 32, 240, 0.8)";
	var grey = "rgba(128, 128, 128, 0.8)";
	var black = "rgba(0, 0, 0, 0.8)";
	var white = "rgba(255, 255, 255,0.8)";

	var commonSize = 10;
	var animationFrame = 0;

	var blocksWide = 100;
	var blocksHigh = 100;

	var left = 0;
	var right = 1;
	var up = 2;
	var down = 3;

    var can, ctx;
	var bgColor = "white";
	var wallColor = "brown";
	var deadColor = "black";
	var blockWidth, blockHeight;
	var blockSize;
	var numberOfWalls = 6;
	var maxTriesToPlaceWalls = numberOfWalls * 100;
	var wallMinLength = 3;
	var walls = [], characters = [], dots = [], destinations = [];
	var audioContext = new AudioContext();

	var score = 0;
	var lives = 3;
	var specialDots = blocksWide/commonSize/2;
	var scoreForEatingDots = 1;
	var scoreForEatingSpecialDots = 5;
	var scoreForEatingCharacter = 20;
	var scoreForLevelUp = 50;

	var dotsEaten = 0;
	var enemiesEaten = 0;
	var level = 1;
	var playerSpeed;
	var characterSpeed;

	var invinsible = 0;
	var superp = 0;
	var ignoreKeysUntil = 0;
	
	var playerInterval, characterInterval, drawAllInterval, mouthInterval;
	var paused = true;

	var mousestartY = 0;
	var mousestartX = 0;
	var touchstartY = 0;
	var touchstartX = 0;
	
	// -----------------------------------------------------------------------

	function handleSwipe(x1, y1, x2, y2)
	{
		var c = characters[0];
		var newX = c.x, newY = c.y, newDirection = c.direction;
		if(x2 < x1-40) { newDirection = 0; newX -= 1; } // left
		if(x2 > x1+40) { newDirection = 1; newX += 1; } // right
		if(y2 < y1-40) { newDirection = 2; newY -= 1; } // up
		if(y2 > y1+40) { newDirection = 3; newY += 1; } // down
		if(isValidMove(newX, newY, blockWidth, blockHeight)) c.direction = newDirection;

		if(paused && (Math.abs(y2-y1) > 40 || Math.abs(x2-x1) > 40)) unPause();

		if(Math.abs(y2-y1) > 200 && Math.abs(x2-x1) > 200) resetGame();
	}
	
	function testBlocks()
	{
		var testSize = 10;
		for(var x = 0; x < blocksWide; x += testSize)
		{
			for(var y = 0; y < blocksHigh; y += testSize)
			{
				ctx.strokeStyle = "yellow";
				ctx.strokeRect(x*blockSize, y*blockSize, blockSize*testSize, blockSize*testSize);
				
				if(characterAt(x, y, 10, 10))
				{
					ctx.strokeStyle = "red";
					ctx.strokeRect(x*blockSize+5, y*blockSize+5, blockSize*testSize-10, blockSize*testSize-10);
				}
				
				if(wallAt(x, y, 10, 10))
				{
					ctx.strokeStyle = "green";
					ctx.strokeRect(x*blockSize+10, y*blockSize+10, blockSize*testSize-20, blockSize*testSize-20	);
				}
			}
		}
	}
	
	function setSizes(w, h)
	{
		w -= 10;
		h -= 10;
		if(w >= h)
		{
			blockSize = h / blocksHigh;
			can.width = h;
			can.height = h;
		}
		if(h > w)
		{
			blockSize = w/2 / blocksWide;
			can.width = w/2;
			can.height = w/2;
		}
	}
	
    function init()
	{
        can = document.getElementById('can1');
		setSizes(document.documentElement.clientWidth, document.documentElement.clientHeight);
		can.style.backgroundColor = bgColor;
        ctx = can.getContext("2d");
		
		blockWidth = 10;
		blockHeight = 10;
		characters = [ { id: 0, color: yellow }, { id: 1, color: blue }, { id: 2, color: purple }, { id: 3, color: cyan }, { id: 4, color: pink } ];
		destinations = [ { x: 0, y: 0 }, { x: blocksWide, y: 0 }, { x: 0, y: blocksHigh*blockHeight }, { x: blocksWide, y: blocksHigh*blockHeight } ]

		//makeCharacters();
		//makeWalls();
		//drawWalls();
		//makeDots();
		//drawDots();
		//showScore();
		//testBlocks();
		resetGame();
		handleEvents();
	}
	
	function handleEvents()
	{
		can.addEventListener("touchstart",  function(event) {event.preventDefault()}, {passive: false})
		can.addEventListener("touchmove",   function(event) {event.preventDefault()}, {passive: false})
		can.addEventListener("touchend",    function(event) {event.preventDefault()}, {passive: false})
		can.addEventListener("touchcancel", function(event) {event.preventDefault()}, {passive: false})

		document.addEventListener('mousedown', function(event)
		{
			mousestartX = event.pageX;
			mousestartY = event.pageY;
		}, false);
		
		document.addEventListener('mouseup', function(event)
		{
			event.preventDefault();
			handleSwipe(mousestartX, mousestartY, event.pageX, event.pageY);
			mousestartX = 0;
			mousestartY = 0;
		}, false); 

		document.addEventListener('touchstart', function(event)
		{
			event.preventDefault();
			touchstartX = event.changedTouches[0].screenX;
			touchstartY = event.changedTouches[0].screenY;
		}, {passive: false});

		document.addEventListener('touchmove',   function(event) { event.preventDefault(); }, {passive: false});
		document.addEventListener('touchcancel', function(event) { event.preventDefault(); }, {passive: false});
		document.addEventListener('touchend',    function(event)
		{
			event.preventDefault();
			handleSwipe(touchstartX, touchstartY, event.changedTouches[0].screenX, event.changedTouches[0].screenY);
			touchstartX = 0;
			touchstartY = 0;
		}, {passive: false}); 

        document.addEventListener("keydown", processKeys, false);
	}
	
	function beep(a) // beep({freq:520, duration:200, vol:100, delay:200, times:1}
	{
		if(!a.freq) a.freq = 500;
		if(!a.duration) a.duration = 150;
		if(!a.vol) a.vol = 100;
		if(!a.times) a.times = 1;
		if(!a.delay) a.delay = 170;
		const oscillator = audioContext.createOscillator();
		const gain = audioContext.createGain();
		oscillator.connect(gain);
		oscillator.frequency.value = a.freq;
		oscillator.type = "square";
		gain.connect(audioContext.destination);
		gain.gain.value = a.vol * 0.01;
		oscillator.start(audioContext.currentTime);
		oscillator.stop(audioContext.currentTime + a.duration * 0.001);
		a.times--;
		if(a.times && !paused) setTimeout(function() {beep(a)}, a.delay);
	}

	function resetGame(noWaitScreen)
	{
		//beep({freq:120, duration: 400});
		//beep({freq:120, duration: 400});
		//beep({freq:1000, duration: 10, delay: 500, times: 20}); // invinsible beep
		ignoreKeysUntil = new Date(new Date().getTime() + 500);
		score = 0;
		lives = 3;
		level = 1;
		playerSpeed = 35;
		characterSpeed = 50;
		resetLevel(noWaitScreen);
	}
	
	function resetLevel(noWaitScreen)
	{
		halt();
		makeWalls();
		makeDots();
		makeCharacters();
		for(var i = 0; i < characters.length; i++)
		{
			characters[i].dead = 0;
			setRandomPosition(characters[i]);
		}
		invinsible = 20;
		superp = 0;
		dotsEaten = 0;
		enemiesEaten = 0;
		reDrawAll();
		if(!noWaitScreen) showMessage("Press any key to start!");
	}
	
	function showMessage(msg, msg2)
	{
		var width = 400;
		var height = 85;
		var x = can.width/2 - width/2;
		var y = can.height/2 - height/2 -100;
		if(msg2 == null) msg2 = "Press P to pause, R to reset game";
		ctx.fillStyle = "black";
		ctx.fillRect(x, y, width, height);
		ctx.fillStyle = "white";
		ctx.fillRect(x+5, y+5, width-10, height-10);
		ctx.fillStyle = "red";
		ctx.font = "30px Arial";
		ctx.fillText("PacMan", x+30, y+30);
		ctx.fillStyle = "black";
		ctx.fillText(msg, x+30, y+55);
		ctx.font = "20px Arial";
		ctx.fillText(msg2, x+30, y+75);
	}
		
	function setRandomPosition(c)
	{
		c.x = -1;
		c.y = -1;
		while(!isValidMove(c.x, c.y, c.width, c.height))
		{
			c.x = getRandomInt(0, blocksWide/commonSize-1) * commonSize;
			c.y = getRandomInt(0, blocksHigh/commonSize-1) * commonSize;
		}
	}
	
	function pause()
	{
		halt();
		reDrawAll();
		showMessage("Press any key to unpause!");
	}

	function halt()
	{
		paused = true;
		if(playerInterval) clearInterval(playerInterval);
		if(characterInterval) clearInterval(characterInterval);
		if(drawAllInterval) clearInterval(drawAllInterval);
		if(mouthInterval) clearInterval(mouthInterval);
		animate();
	}
	
	function showScore()
	{
		var player = characters[0];
		var str = "";
		str +=
		"Level: " + level + "<br>" +
		"Score: " + score + "<br>" +
		"Dots eaten: " + dotsEaten + " of " + dots.length + "<br>" +
		"Ghost eaten: " + enemiesEaten + "<br>" +
		"Lives: " + lives + "<br>" +
		"Speed &nbsp;player: " + playerSpeed + " ghost: " + characterSpeed + "<br>" +
		"<br>";
		
		/*
		for(var i = 0; i < walls.length; i++) str += "walls[" + i + "] x: " + walls[i].x + " y: " + walls[i].y + " width: " + walls[i].width + " height: " + walls[i].height + "<br>";
		//str += "<br>";
		//for(var i = 0; i < dots.length; i++) str += "dots[" + i + "] x: " + dots[i].x + " y: " + dots[i].y + " width: " + dots[i].width + " height: " + dots[i].height + "<br>";
		
		str +=
		"<br>" +
		"can &nbsp; width: " + can.width + " height: " + can.height + "<br>" +
		"player &nbsp; x: " + player.x + " y: " + player.y + " width: " + player.width + " height: " + player.height + " dir: " + player.direction + "<br>" +
		"block &nbsp; width: " + blockWidth + " height: " + blockHeight + " size: " + blockSize + "<br>" +
		"";
		*/
		document.getElementById("scoreBoard").innerHTML = str;
	}

	function reDrawAll()
	{
		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, can.width, can.height); // clear canvas
		drawWalls();
		drawDots();
		for(var i = characters.length-1; i >= 0; i--) drawCharacter(characters[i]);
		showScore();
	}
	
	function animate()
	{
		if(!paused)
		{
			for(var i = characters.length-1; i >= 0; i--) drawCharacter(characters[i]);
			showScore();
			//if(invinsible > 0 && animationFrame % 10 == 0) beep({freq:1000, duration: 10}); // invinsible beep
			//if(superp > 0 && animationFrame % 15 == 0) beep({freq:1000, duration: 10}); // invinsible beep
			animationFrame++;
		}
		window.requestAnimationFrame(animate);
	}
	
	function unPause()
	{
		paused = false;
		if(audioContext == null) audioContext = new AudioContext();
		playerInterval = setInterval(movePlayer, playerSpeed);
		characterInterval = setInterval(moveCharacter, characterSpeed);
		mouthInterval = setInterval(openCloseMouth, 150);
		reDrawAll();
    }
	
	function openCloseMouth() { characters[0].mouthClosed = !characters[0].mouthClosed; }

	function playerDies()
	{
		if(audioContext == null) audioContext = new AudioContext();
		//beep({freq:120, duration: 400});
		//beep({freq:1000, duration: 10, delay: 1500, times: 20}); // invinsible beep
		score = 0;
		lives--;
		invinsible = 15;
		if(lives <= 0)
		{
			halt();
			reDrawAll();
			resetGame(true);
			showMessage("YOU DIED!", "");
		}
	}
	
	function levelUp()
	{
		score += scoreForLevelUp;
		characterSpeed -= 5;
		if(characterSpeed < playerSpeed) characterSpeed = playerSpeed;
		level++;
		resetLevel();
	}
	
	// -----------------------------------------------------------------------

	function makeDots()
	{
		dots = [];
		for(var x = 0; x < blocksWide; x += 10)
		{
			for(var y = 0; y < blocksHigh; y += 10)
			{
				if(!wallAt(x, y, commonSize, commonSize))
				{
					dots.push({ x: x, y: y, width: commonSize, height: commonSize });
				}
			}
		}

		for(var i=0; i < specialDots; i++)
		{
			var dot = dots[getRandomInt(0, dots.length-1)];
			dot.special = true;
		}
	}
	
	function drawDots()
	{
		for(var i=0; i < dots.length; i++)
		{
			drawDot(dots[i].x, dots[i].y);
		}
	}
	
	function drawDot(x, y)
	{
		var dotMatches = getDots(x, y);
		for(var i = 0; i < dotMatches.length; i++)
		{
			var dot = dotMatches[i];
			ctx.fillStyle = orange;
			if(dot.eaten) ctx.fillStyle = lightYellow;
			if(!dot.eaten && dot.special) ctx.fillStyle = "green";
			ctx.beginPath();

			var arcX = dot.x * blockSize + blockWidth * blockSize / 2;
			var arcY = dot.y * blockSize + blockWidth * blockSize / 2;
			var arcSize = blockWidth*blockSize/6;
			if(dot.special) arcSize = blockWidth*blockSize/4;

			ctx.arc(arcX, arcY, arcSize, 0.2 * Math.PI, 2 * Math.PI, false); 
			ctx.fill();
		}
	}
	
	function getDots(x, y)
	{
		var dotMatches = [];
		for(var i=0; i < dots.length; i++) if(collisionTest(x, y, blockWidth, blockHeight, dots[i].x, dots[i].y, dots[i].width, dots[i].height)) dotMatches.push(dots[i]);
		return dotMatches;
	}
	
	function eatDot(x, y)
	{
		var dotMatches = getDots(x, y);
		for(var i = 0; i < dotMatches.length; i++)
		{
			var dot = dotMatches[i];
			if(dot.eaten) continue;
			if(dot.special)
			{
				superp = 300;
				score += scoreForEatingSpecialDots;
				//beep({freq:1000, duration: 10, delay: 500, times: 20}); // invinsible beep
			}
			else score += scoreForEatingDots;
			dotsEaten++;
			dot.eaten = true;
			showScore();
			if(dotsEaten == dots.length) levelUp();
		}
	}

	// -----------------------------------------------------------------------

	function makeWalls()
	{
		var wallSpacing = 10;
		walls = [];
		var triesLeft = maxTriesToPlaceWalls;
		for(var i = 0; i < numberOfWalls && triesLeft > 0; i++)
		{
			triesLeft--;
			var direction = getRandomInt(0, 1);
			var x1 = getRandomInt(1, (blocksWide/wallSpacing)-2) * wallSpacing;
			var y1 = getRandomInt(1, (blocksHigh/wallSpacing)-2) * wallSpacing;
			var width1 = getRandomInt(wallMinLength, (blocksWide/wallSpacing)-3) * wallSpacing;
			var height1 = getRandomInt(wallMinLength, (blocksHigh/wallSpacing)-3) * wallSpacing;
			
			if(direction == 0) height1 = commonSize;
			if(direction == 1) width1 = commonSize;
			//if(direction == 0 && wallMinLength * blockWidth > width1) { i--; continue; }
			//if(direction == 1 && wallMinLength * blockHeight > height1) { i--; continue; }
			
			if(
				!wallAt(x1-blockWidth, y1-blockHeight, width1, height1) &&
				!wallAt(x1+blockWidth, y1+blockHeight, width1, height1) &&
				!wallAt(x1, y1, blockWidth, blockHeight)
				//!wallAt(x1-blockWidth, y1-blockHeight, blockWidth*3, blockHeight*3)
			) walls.push( { x: x1, y: y1, width: width1, height: height1 } );
			else i--;
		}
		if(triesLeft == 0) console.log("ran out of wall space");
	}
	
    function drawWalls()
	{
		for(var i = 0; i < walls.length; i++)
		{
			if(walls[i].color == undefined) walls[i].color = wallColor;
			ctx.fillStyle = walls[i].color;
			ctx.fillRect(walls[i].x*blockSize, walls[i].y*blockSize, walls[i].width*blockSize, walls[i].height*blockSize);
		}
    }
	
	// -----------------------------------------------------------------------

	function makeCharacters()
	{
		for(var i = 0; i < characters.length; i++)
		{
			var c = characters[i];
			c.width = commonSize;
			c.height = commonSize;
			setRandomPosition(c);
			while(wallAt(c.x, c.y, c.width, c.height)) setRandomPosition(c);
			var watchDogCount = 0;
			while(watchDogCount < 20 && characterAt(c.x, c.y, c.width, c.height, c.id)) { setRandomPosition(c); watchDogCount++; }
			if(watchDogCount >= 20) alert("stuck in makeCharacters " + watchDogCount);
			drawCharacter(c);
		}
	}
	
    function moveCharacter()
	{
		var player = characters[0];
		for(var characterNum = 1; characterNum < characters.length; characterNum++)
		{
			var c = characters[characterNum];
			if(c.dead > 0) { c.dead--; continue; }
			var playerDistance = getDistance(player.x, c.x, player.y, c.y);
			var bestX = c.x;
			var bestY = c.y;
			var scramble = [ 0, 1, 2, 3 ];
			scramble.sort(() => Math.random() - 0.5);
			for(var i = 0; i < 4; i++)
			{
				var newX = c.x;
				var newY = c.y;
				if(i === scramble[0]) { newX = c.x - 1; }
				if(i === scramble[1]) { newX = c.x + 1; }
				if(i === scramble[2]) { newY = c.y - 1; }
				if(i === scramble[3]) { newY = c.y + 1; }
				if(!isValidMove(newX, newY, blockWidth, blockHeight)) continue;
				
				if(c.dest == undefined) c.dest = getRandomInt(0, destinations.length-1);
				var destX = destinations[c.dest].x;
				var destY = destinations[c.dest].y; 
				if(!invinsible && !superp && playerDistance < 200) { destX = player.x; destY = player.y; }

				var bestDistance = getDistance(destX, bestX, destY, bestY);
				var newDistance = getDistance(destX, newX, destY, newY);
				if(newDistance < bestDistance) { bestX = newX; bestY = newY; }
			}
			if(bestX == c.x && bestY == c.y) c.dest = getRandomInt(0, destinations.length-1); // stuck, change destination
			c.x = bestX;
			c.y = bestY;
			var c2 = characterAt(c.x, c.y, blockWidth, blockWidth, c.id);
			if(c2 != null && !c.dead && c2.id == 0)
			{
				if(superp) eatCharacter(c);
				if(!superp && !invinsible) playerDies();
			}
		}
    }
	
    function drawCharacter(c)
	{
		ctx.fillStyle = bgColor;
		ctx.fillRect(c.oldX*blockSize, c.oldY*blockSize, c.width*blockSize, c.height*blockSize); // erase previous location
		if(c.oldX != null) drawDot(c.oldX, c.oldY)
		ctx.fillStyle = bgColor;
		ctx.fillRect(c.x*blockSize, c.y*blockSize, c.width*blockSize, c.height*blockSize); // erase current location
		ctx.fillStyle = c.color;
		if(c.dead > 0) ctx.fillStyle = deadColor;
		var num1 = 2;//1.6; // 1.6
		var num2 = 3; // 

		if(c.id == 0)
		{
			//ctx.strokeStyle = grey;
			//ctx.strokeRect(c.x*blockSize, c.y*blockSize, c.width*blockSize-4, c.height*blockSize-4);
			if(invinsible) ctx.fillStyle = orange;
			if(superp) ctx.fillStyle = red;
			ctx.beginPath();
			var mouthOpenValue = 30;
			// left, right, up, down (180, 0, 270?, 90?)
			if(c.mouthClosed) mouthOpenValue = 1;
			var n1 = (c.x * blockSize) + (c.width * blockSize / 2);
			var n2 = (c.y * blockSize) + (c.height * blockSize / 2);
			var n3 = (c.width * blockSize) / num2;
			if (c.direction == 0) ctx.arc(n1, n2, n3, (Math.PI / 180) * (179 - mouthOpenValue), (Math.PI / 180) * (180 + mouthOpenValue), true);
			else if (c.direction == 1) ctx.arc(n1, n2, n3, (Math.PI / 180) * mouthOpenValue, (Math.PI / 180) * (360 - mouthOpenValue));
			else if (c.direction == 2) ctx.arc(n1, n2, n3, (Math.PI / 180) * (269 - mouthOpenValue), (Math.PI / 180) * (270 + mouthOpenValue), true);
			else ctx.arc(n1, n2, n3, (Math.PI / 180) * (89 + mouthOpenValue), (Math.PI / 180) * (90 - mouthOpenValue));
			ctx.lineTo(n1, n2); // mouth
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}
		else
		{
			ctx.beginPath();
			var arcX = (c.x * blockSize) + (c.width * blockSize / 2);
			var arcY = (c.y * blockSize) + (c.height * blockSize / 2);
			var arcSize = (c.width * blockSize) / num2;
			ctx.arc(arcX, arcY, arcSize, 0, 2 * Math.PI, false); // body
			ctx.closePath();
			ctx.fill();
			ctx.stroke();
		}
		c.oldX = c.x;
		c.oldY = c.y;
    }
	
    function movePlayer()
	{
		if(invinsible > 0) invinsible--;
		if(superp > 0) superp--;
		var player = characters[0];
		var newX = player.x, newY = player.y, newDirection = player.direction;
		
		if(newDirection === 0) newX = player.x - 1;
		if(newDirection === 1) newX = player.x + 1;
		if(newDirection === 2) newY = player.y - 1;
		if(newDirection === 3) newY = player.y + 1;

		if(newX < 0) newX = 0;
		if(newY < 0) newY = 0;
		if(newX + blockWidth > can.width) newX = can.width - blockWidth;
		if(newY + blockHeight > can.height) newY = can.width - blockHeight;

		if(isValidMove(newX, newY, blockWidth, blockHeight))
		{
			player.x = newX;
			player.y = newY;
			if(!invinsible) eatDot(player.x, player.y);
			
			var c = characterAt(player.x, player.y, blockWidth, blockWidth, player.id);
			if(c != null && !c.dead)
			{
				if(superp) eatCharacter(c);
				if(!superp && !invinsible) playerDies();
			}
		}
    }
	
	function eatCharacter(c)
	{
		//beep({freq:800, duration: 400});
		enemiesEaten++;
		score += scoreForEatingCharacter;
		//setRandomPosition(c);
		c.dead = 30;
	}
	
	// -----------------------------------------------------------------------

    function processKeys(e)
	{
		if(e.ctrlKey) return; // ignore all ctrl keys
		if(event.keyCode < 32 || event.keyCode > 110) return; // ignore alt, tab, other strange command characters
		if(ignoreKeysUntil > 0 && ignoreKeysUntil > new Date().getTime()) return;
		ignoreKeysUntil = 0;

		var player = characters[0];
		var newX = player.x, newY = player.y, newDirection = player.direction;
		if(e.key === "ArrowLeft" || e.key === "a") { newDirection = 0; newX -= 1; }
		if(e.key === "ArrowRight" || e.key === "d") { newDirection = 1; newX += 1; }
		if(e.key === "ArrowUp" || e.key === "w") { newDirection = 2; newY -= 1; }
		if(e.key === "ArrowDown" || e.key === "s") { newDirection = 3; newY += 1; }
		if(isValidMove(newX, newY, blockWidth, blockWidth)) player.direction = newDirection;
		player.direction = newDirection;
		
		if(e.key === "p") { if(!paused) pause(); else unPause(); }
		else if(paused) unPause(); // anykey unpauses
		if(e.key === "r") resetGame();
		if(e.key === "l") levelUp();
    }
	
	function getDistance(x1, x2, y1, y2)
	{
		var distance = 0;
		distance = Math.abs(x1 - x2) + Math.abs(y1 - y2); // (10)-(20)=-10 (-10)-(-10)=0. (-10)-(-30)=20. (-20)-(20)=-40
		return distance;
	}
	
	function isValidMove(x, y, width, height) // checks if within board
	{
		if(x < 0) return false;
		if(x + commonSize > blocksWide) return false;
		if(y < 0) return false;
		if(y + commonSize > blocksHigh) return false;
		
		return !wallAt(x, y, width, height);
	}
	
	function wallAt(x, y, width, height)
	{
		for(var i = 0; i < walls.length; i++)
		{
			if(collisionTest(x, y, width, height, walls[i].x, walls[i].y, walls[i].width, walls[i].height)) return walls[i];
		}
		return null;
	}
	
	function collisionTest(x1, y1, width1, height1, x2, y2, width2, height2)
	{
		if(
		x1 + width1 > x2 &&
		x1 < x2 + width2 &&
		y1 + height1 > y2 &&
		y1 < y2 + height2) return true;
		return false;
	}

	function characterAt(x, y, width, height, notId)
	{
		for(var i = 0; i < characters.length; i++)
		{
			var c = characters[i];
			if(c.id != notId && !c.dead && collisionTest(x, y, width, height, c.x, c.y, c.width, c.height)) return c;
		}
		return null;
	}
		
	function getRandomInt(min, max)
	{	
		if(min > max) { var temp = min; min = max; max = temp; }
		min = Math.ceil(min);
		max = Math.floor(max);
		if(max > 0) max++;
		return Math.floor(Math.random() * (max - min) + min);
	}
 
</script>

</html>
